// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'
// Upgrade NOTE: replaced '_World2Object' with 'unity_WorldToObject'
Shader "Custom/BVShader2" {	Properties {							BV_1 ("BV_1", Float) = 1.0			BV_2 ("BV_2", Color) = (0.0, 0.0, 0.0, 1.0)						_DiffuseColor ("_DiffuseColor", Color) = (0.0, 0.0, 0.0, 1.0)		BV_4 ("BV_4", 2D) = "black" {}				BV_5 ("BV_5", Float) = 1.0		BV_6 ("BV_6", Float) = 0.0		BV_7 ("BV_7", float) = 0		BV_8 ("BV_8", int) = 0		BV_9 ("BV_9", Color) = (0.0, 0.0, 0.0, 1.0)		BV_10 ("BV_10", Float) = 1.0		BV_11 ("BV_11", Float) = 1.0		BV_12 ("BV_12", int) = 0			BV_13 ("BV_13", int) = 1		BV_14 ("BV_14", 2D) = "black" {}		BV_15 ("BV_15", Float) = 1.0						BV_16 ("BV_16", Float) = 0.5		BV_17 ("BV_17", Float) = 1.0		BV_18 ("BV_18", Float) = 5.0		BV_19 ("BV_19", int) = 0		BV_20 ("BV_20", 2D) = "black" {}			BV_21 ("BV_21", int) = 0		BV_22 ("BV_22", Float) = 0.0		BV_23 ("BV_23", Float) = 1.0		BV_24 ("BV_24", Color) = (1.0, 1.0, 1.0, 1.0)		BV_25 ("BV_25", Float) = 1.0		BV_26 ("BV_26", Float) = 1.0		   }   	SubShader {			Tags {"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent"}			Tags { "LightMode" = "ForwardBase" }			Blend SrcAlpha OneMinusSrcAlpha             Alphatest Greater 0					Pass {				Lighting On			 			CGPROGRAM			#include "UnityCG.cginc"
			#include "AutoLight.cginc"
			#include "Lighting.cginc"
						#pragma glsl
			#pragma target 3.0
			#pragma vertex vert
			#pragma fragment frag alpha
				#pragma multi_compile_fwdbase
			uniform float			BV_1;			uniform float4			BV_2;			uniform float4			_DiffuseColor;			uniform sampler2D		BV_4;			uniform float4			BV_4_ST;			uniform float			BV_5;			uniform float			BV_6;			uniform float			BV_7;			uniform float			BV_8;			uniform float			BV_10;			uniform float			BV_11;			uniform float4			BV_9;			uniform int				BV_12;				uniform int				BV_13;			uniform sampler2D		BV_14;			uniform float4			BV_14_ST;			uniform float			BV_15;			uniform float BV_16; 			uniform float BV_17; 			uniform float BV_18; 			uniform sampler2D		BV_20;			uniform float4			BV_20_ST;			uniform int				BV_19;			uniform int				BV_21;			uniform float			BV_22;			uniform float			BV_23;			uniform float4			BV_24;			uniform float			BV_25;						uniform float			BV_26;			struct appdata			{				float4 vertex:POSITION;					float3 BV_27:NORMAL;					float2 BV_28:TEXCOORD0;				};						struct v2f			{					float4 pos:SV_POSITION;					float2 UV:TEXCOORD0;					float4 Pw:TEXCOORD1;  				float3 VwLocal:TEXCOORD2;					float3 BV_50:TEXCOORD3;					float3 BV_48:TEXCOORD4;					float3 BV_49:TEXCOORD5;					LIGHTING_COORDS(6,7)			};			void BV_33(float3 BV_31, out float3 BV_34, out float3 BV_35)			{				float s=BV_31.z<0?-1:1;				float3 BV_32=s*BV_31;				float e=BV_32.z;				float h=1/(1+e);				float3 v=float3(BV_32.y,-BV_32.x,0);				float hvx=h*v.x;				float hvxy=hvx*v.y;				BV_34=float3(e+hvx*v.x,hvxy,v.y);				BV_35=float3(hvxy,e+h*v.y*v.y,-v.x);				BV_34*=s;BV_35*=s;			}						v2f vert(appdata v) 			{				v2f output;					output.pos = mul(UNITY_MATRIX_MVP, v.vertex);				output.UV = v.BV_28;				output.Pw = mul(unity_ObjectToWorld, v.vertex);				output.VwLocal = _WorldSpaceCameraPos - output.Pw.xyz;				output.BV_50 = mul(float4(v.BV_27, 0), unity_WorldToObject).xyz;				float3 Tu, Tv;				BV_33(output.BV_50, Tu, Tv);				output.BV_48 = Tu;					output.BV_49 = Tv;				TRANSFER_VERTEX_TO_FRAGMENT(output);				return output;			}			struct BV_36 { 				float3 BV_37; 				float3 BV_38; 				float3 BV_39; 			}; 						float4 BV_40(sampler2D BV_41, float2 BV_28, float4x4 BV_42, float3 BV_43, bool BV_44)			{				float2 st = mul(BV_42, float4(BV_28, 0.0f, 1.0f)).xy;				float4 result = tex2D(BV_41, st) * float4(BV_43, 1.0f);				if (BV_44) 					result.rgb = 1.0f - result.rgb;				return result;			}						float3 BV_45(sampler2D BV_46, float2 BV_28, float4x4 BV_42, float BV_47, float3 BV_48, float3 BV_49, float3 BV_50)			{				float3x3 mtxTangent = {BV_48, BV_49, BV_50};					BV_48 = normalize(mul(mul((float3x3)BV_42, float3(1.0f, 0.0f, 0.0f)), mtxTangent)); 				BV_49 = normalize(mul(mul((float3x3)BV_42, float3(0.0f, 1.0f, 0.0f)), mtxTangent)); 				float3 avg = (1.0f / 3.0f).xxx;	float2 offset = max(fwidth(BV_28), float2(0.001f, 0.001f)); 					float2 st = mul(BV_42, float4(BV_28, 0.0f, 1.0f)).xy;				float h0 = dot(tex2D(BV_46, st).xyz, avg); 				float hx = dot(tex2D(BV_46, st + float2(offset.x, 0.0f)).xyz, avg); 				float hy = dot(tex2D(BV_46, st + float2(0.0f, offset.y)).xyz, avg); 				float2 BV_51 = float2(h0 - hx, h0 - hy) / offset;				return normalize(BV_50 + (BV_51.x * BV_48 + BV_51.y * BV_49) * BV_47);				}						float3 BV_52(sampler2D Map2, float2 BV_28, float4x4 BV_42, float BV_47, float3 BV_48, float3 BV_49, float3 BV_50)			{				float2 st = mul(BV_42, float4(BV_28, 0.0f, 1.0f)).xy;				float3 BV_56 =  2.0 * tex2D(Map2, st).xyz - 1.0;				return normalize(BV_47 * (BV_56.x * BV_48 + BV_56.y * BV_49) + BV_56.z * BV_50);			}						float3 BV_53( float3 BV_39, float3 BV_54 )			{ 				return normalize( BV_39 + BV_54 ); 			} 			float4 BV_55( float3 BV_56, float3 BV_39, float3 BV_54, float3 BV_57 )			{ 				float BV_58 = saturate(dot(BV_56, BV_39)); 				float BV_59 = saturate(dot(BV_56, BV_54)); 				float BV_60 = saturate(dot(BV_56, BV_57)); 				float BV_61 = saturate(dot(BV_54, BV_57)); 				return float4( BV_58, BV_59, BV_60, BV_61 ); 			} 			float2 BV_62( float3 BV_57, float3 T, float3 B )			{ 				float BV_63 = dot(BV_57, T); 				float BV_64 = dot(BV_57, B); 				return float2( BV_63, BV_64 ); 			} 						float2 BV_65( float BV_66 ) { 				float r2 = BV_66 * BV_66; 				float2 ab; 				ab.x = 1.0 - 0.5 * r2 / (r2 + 0.33); 				ab.y = 0.45 * r2 / (r2 + 0.09); 				return ab; 			} 						float3 BV_67( float4 BV_68, float3 BV_56, float3 BV_39,  float3 BV_54, float2 ab, float3 BV_37 ) { 				float BV_58 = BV_68.x; 				float BV_59 = BV_68.y; 				float sinTan = sqrt( (1.0-BV_58*BV_58) * (1.0-BV_59*BV_59) ); 				sinTan /= 0.0000001 + max( BV_58, BV_59); 				float3 Vp = normalize( BV_54 - BV_59 * BV_56 ); 				float3 Lp = normalize( BV_39 - BV_58 * BV_56 ); 				float c = saturate( dot( Vp, Lp ) ); 				return BV_58 * (ab.x + ab.y * c * sinTan ) * BV_37; 			} 						float3 BV_69( float4 BV_68, float3 BV_37 ) { 				return BV_68.x * BV_37;			} 						float BV_70(float3 BV_56, float3 BV_57, float4 BV_68, float BV_73)			{				const float EPSILON = 1e-6f;				const float SOFTEN_MAX = 80.0f;				const float FOUR_PI = 4.0f * 3.141592654f;				float NLNV = BV_68.x * BV_68.y;				if (NLNV < EPSILON) return 0.0f;				float denom = FOUR_PI * sqrt(NLNV);				float NH2 = BV_68.z * BV_68.z;				float3 proj = BV_57 - BV_68.z * BV_56;				float proj2 = dot(proj, proj);				float BV_103 = pow(2.0f, 8.0f * BV_73);				float BV_51 = BV_103 - SOFTEN_MAX;				if (BV_51 > 0.0f) BV_103 = SOFTEN_MAX + sqrt(BV_51);				float BV_104 = BV_103 * BV_103;				float result = 0.5f * exp(-(BV_104 * proj2) / NH2) * BV_104 / denom;				BV_103 *= 0.5f;				BV_104 = BV_103 * BV_103;				result += exp(-(BV_104 * proj2) / NH2) * BV_104 / denom;				BV_103 *= 0.5f;				BV_104 = BV_103 * BV_103;				result += 1.5f * exp(-(BV_104 * proj2) / NH2) * BV_104 / denom;				return result * BV_68.x;			}			float BV_71(float4 BV_68, float2 BV_72, float BV_73, float BV_74)			{				const float EPSILON = 1e-6f;				const float SOFTEN_MAX = 80.0f;				const float FOUR_PI = 4.0f * 3.141592654f;				float NLNV = BV_68.x * BV_68.y;				if (NLNV < EPSILON) return 0.0f;				float denom = FOUR_PI * sqrt(NLNV);				float2 BV_108 = BV_72 * BV_72;				float NH2 = BV_68.z * BV_68.z;				float2 BV_105;				BV_105.x = pow(2.0f, 8.0f * BV_73);				BV_105.y = BV_105.x * BV_74;				float BV_51 = BV_105.x - SOFTEN_MAX;				if (BV_51 > 0.0f) BV_105.x = SOFTEN_MAX + sqrt(BV_51);				BV_51 = BV_105.y - SOFTEN_MAX;				if (BV_51 > 0.0f) BV_105.y = SOFTEN_MAX + sqrt(BV_51);				float2 BV_106 = BV_105 * BV_105;				float BV_107 = dot(BV_108, BV_106);				float result = 0.5f * exp(-BV_107 / NH2) * BV_105.x * BV_105.y / denom;				BV_105 *= 0.5f;				BV_106 = BV_105 * BV_105;				BV_107 = dot(BV_108, BV_106);				result += exp(-BV_107 / NH2) * BV_105.x * BV_105.y / denom;				BV_105 *= 0.5f;				BV_106 = BV_105 * BV_105;				BV_107 = dot(BV_108, BV_106);				result += 1.5f * exp(-BV_107 / NH2) * BV_105.x * BV_105.y / denom;				return result * BV_68.x;			}			float3 BV_75( float d, float g, float f, float3 BV_38 )			{ 				return BV_38 * d * g * f; 			} 			float BV_76(float4 BV_68, float BV_16, float BV_17, float BV_18 )			{ 				float f = lerp(BV_16, BV_17, pow(1.0f - BV_68.y, BV_18)); 				return f; 			} 			float BV_80( float4 BV_68, float BV_81 )			{ 				float VHc = 1 - BV_68.w; 				float VHc2 = VHc *  VHc; 				float f = 4.0f * BV_81 * (VHc * VHc2 * VHc2); 				float2 ior2 = float2(BV_81 - 1, BV_81 + 1 ); 				ior2 *= ior2; 				f = (ior2.x + f) / ior2.y; 				return f; 			}			float BV_82(float3 value)			{				return dot(value, (1.0f / 3.0f).xxx);			}			float3 BV_83(int type, float2 BV_28, float3 BV_48, float3 BV_49, float3 BV_50, float3 Vw)			{				float4x4 bmt = {BV_14_ST.x,0,0,BV_14_ST.z,0,BV_14_ST.y,0,BV_14_ST.w,0,0,1,0,0,0,0,1};					if (type == 1)					BV_50 = BV_45(BV_14, BV_28, bmt, BV_15, BV_48, BV_49, BV_50);				else if (type == 2)					BV_50 = BV_52(BV_14, BV_28, bmt, BV_15, BV_48, BV_49, BV_50);								BV_50 = dot(-Vw, BV_50) < 0 ? BV_50 : -BV_50;				return BV_50;			}			float3 BV_84(float3 BV_85)			{				float3 BV_86;				if (0.0 == _WorldSpaceLightPos0.w) 				{					BV_86 = normalize(float3(_WorldSpaceLightPos0.xyz));				} 				else 				{					float3 vtx2Light = float3(_WorldSpaceLightPos0.xyz - BV_85);					BV_86 = normalize(vtx2Light);				}									return BV_86;			}						BV_36 BV_87( float BV_88, float3 color, float3 BV_89, float3 BV_90 )			{ 				BV_36 irrad; 				irrad.BV_37 = color * BV_88;				irrad.BV_38 = BV_89 * BV_88;				irrad.BV_39 = normalize( BV_90 ); 				return irrad; 			} 			float3 BV_91(float3 BV_92, float2 BV_28, float BV_93)			{								if(BV_93 == 0.0f)					return BV_92;				if(BV_93 == 1.0f)				{					float4x4 dmt = {BV_4_ST.x,0,0,BV_4_ST.z,0,BV_4_ST.y,0,BV_4_ST.w,0,0,1,0,0,0,0,1};							float4 BV_94 = BV_40(BV_4, BV_28, dmt, float3(1,1,1), false);					return BV_94.xyz;				}				if(BV_93 >0.0f && BV_93 < 1.0f)				{					float4x4 dmt = {BV_4_ST.x,0,0,BV_4_ST.z,0,BV_4_ST.y,0,BV_4_ST.w,0,0,1,0,0,0,0,1};						float4 BV_94 = BV_40(BV_4, BV_28, dmt, float3(1,1,1), false);					float lerpfactor = BV_93 * BV_94.w;					float3 lerpcolor = BV_92 * (1- lerpfactor) + BV_94.xyz * lerpfactor;					return lerpcolor;				}				return BV_92;						}						float3 BV_95(float3 BV_157, float2 BV_28, int BV_109)			{				float3 ret = BV_157;				if(BV_109 == 1)				{					float4x4 bmt = {BV_20_ST.x,0,0,BV_20_ST.z,0,BV_20_ST.y,0,BV_20_ST.w,0,0,1,0,0,0,0,1};						float4 BV_96 = BV_40(BV_20, BV_28, bmt, float3(1,1,1), false);					ret = ret * BV_96.xyz;				}				return ret;			}			float3 BV_97(float2 BV_28, float3 BV_92)			{				float3 BV_43 = BV_92;				float4x4 dmt = {BV_4_ST.x,0,0,BV_4_ST.z,0,BV_4_ST.y,0,BV_4_ST.w,0,0,1,0,0,0,0,1};				float4 BV_94 = BV_40(BV_4, BV_28, dmt, float3(1,1,1), false);				float3 src = BV_94.xyz;							   float3 result;			   result.r = (src.r < 0.5f) ? src.r * 2.0f * BV_43.r : 1.0f - 2.0f * (1.0f - src.r) * (1.0f - BV_43.r);			   result.g = (src.g < 0.5f) ? src.g * 2.0f * BV_43.g : 1.0f - 2.0f * (1.0f - src.g) * (1.0f - BV_43.g);			   result.b = (src.b < 0.5f) ? src.b * 2.0f * BV_43.b : 1.0f - 2.0f * (1.0f - src.b) * (1.0f - BV_43.b);			   result = lerp(src, result, 0.5f);			   result = lerp(result, BV_43 * result, 0.5f);			   return result;			}								float4 frag(v2f input) : COLOR			{				float G = 1.000000; 				float F = 1.000000; 				float3 ambientlight = float3(UNITY_LIGHTMODEL_AMBIENT.xyz);				float3 Vw = normalize(input.VwLocal);					float3 BV_48 = normalize(input.BV_48);				float3 BV_49 = normalize(input.BV_49);				float3 BV_50 = normalize(input.BV_50);					   BV_50 = BV_83(BV_13, input.UV, BV_48,  BV_49, BV_50 , Vw);				float3 BV_86 = BV_84(input.Pw);				BV_36 BV_110 = BV_87( LIGHT_ATTENUATION(input), _LightColor0.rgb, float3(1,1,1), BV_86 ); ; 					float3 BV_111 = BV_53( BV_86, Vw ); 				float4 BV_112 = BV_55( BV_50, BV_86, Vw, BV_111 ); 				float3 BV_98;				if(BV_8 > 0)				{					BV_98 = BV_97(input.UV, _DiffuseColor.xyz);				}				else				{					float3 BV_113 = BV_91(_DiffuseColor.xyz, input.UV, BV_7);					BV_98 = BV_95(BV_113, input.UV, BV_19);				}				float3 BV_114;				if(BV_6 > 0.0f)				{					float2 BV_115 = BV_65( BV_6 ); 					BV_114 = BV_67( BV_112, BV_50, BV_110.BV_39, Vw, BV_115, BV_110.BV_37 ); 				}				else				{					BV_114 = BV_69( BV_112, BV_110.BV_37 ); 				}				float BV_116;				if(BV_21 > 0)				{					float2 BV_117 = BV_62( BV_111, BV_48, BV_49 ); 					BV_116 = BV_71( BV_112, BV_117, BV_11, BV_22 ); 				}				else				{					BV_116 = BV_70( BV_50, BV_111, BV_112, BV_11 ); 				}							float3 BV_118 = BV_75( BV_116, G, F, BV_110.BV_38 ); 				float BV_119;				if(BV_26 > 1.0)				{					BV_119 = BV_80(BV_112, BV_26);				}				else				{					BV_119 = BV_76( BV_112, BV_16, BV_17, BV_18 ); 				}				BV_98 = BV_98 * BV_23 + BV_24.xyz * (1.0f -BV_23);				float3 BV_99 = BV_1  * BV_98 * ambientlight;				float3 BV_100 = BV_2.xyz;				float3 BV_101 = BV_98 * BV_114 * BV_5;								float3 BV_102 = BV_9.xyz * BV_10 * BV_119 * BV_118;				if(BV_12 == 1)					BV_102  = BV_98 * BV_10 * BV_119 * BV_118; 								float4 BV_156 = float4(BV_99 + BV_100 + BV_101 + BV_102, BV_23);								return BV_156;						}ENDCG					} // Pass
 	} // SubShader
 	   	// Define a fallback shader. 
	FallBack "Diffuse"}