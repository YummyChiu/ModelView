// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'
// Upgrade NOTE: replaced '_World2Object' with 'unity_WorldToObject'
Shader "Custom/BVShader3" {	Properties {					BV_5 ("BV_5", Float) = 1.0		BV_7 ("BV_7", Float) =  1.0		_DiffuseColor ("_DiffuseColor", Color) = (0.0, 0.0, 0.0, 1.0)		BV_4 ("BV_4", 2D) = "black" {}				BV_120 ("BV_120", Float) = 0.0		BV_121 ("BV_121", Color) = (0.0, 0.0, 0.0, 1.0)		BV_122 ("BV_122", Float) = 0.0		BV_123 ("BV_123", Float) = 0.0		BV_124 ("BV_124", Float) = 0.0		BV_125 ("BV_125", Float) = 0.0		BV_126("BV_126", int) = 0		BV_127 ("BV_127", Float) = 0.0				BV_128 ("BV_128", Float) = 1.0		BV_129 ("BV_129", Float) = 1.0		BV_10 ("BV_10", Float) = 1.0		BV_130 ("BV_130", Float) = 1.0		BV_131("BV_131", Float) = 1.0		BV_16 ("BV_16", Float) = 0.5		BV_17 ("BV_17", Float) = 1.0		BV_18 ("BV_18", Float) = 5.0		BV_13 ("BV_13", int) = 0		BV_14 ("BV_14", 2D) = "black" {}		BV_15 ("BV_15", Float) = 1.0						   }   	SubShader {			Tags {"RenderType"="Opaque"}			Tags { "LightMode" = "ForwardBase" }			Blend SrcAlpha OneMinusSrcAlpha             Alphatest Greater 0					Pass {				Lighting On			 			CGPROGRAM			#include "UnityCG.cginc"
			#include "AutoLight.cginc"
			#include "Lighting.cginc"
						#pragma glsl
			#pragma target 3.0
			#pragma vertex vert
			#pragma fragment frag alpha
				#pragma multi_compile_fwdbase
			uniform float			BV_5;			uniform float			BV_7;			uniform float4			_DiffuseColor;			uniform sampler2D		BV_4;			uniform float4			BV_4_ST;			uniform float			BV_120;			uniform float4			BV_121;			uniform float			BV_122;			uniform float			BV_123;			uniform float			BV_124;			uniform float			BV_125;			uniform int				BV_126;						uniform float			BV_127;						uniform float			BV_128;			uniform float			BV_129;				uniform float			BV_10;			uniform float			BV_130;			uniform float			BV_131;			uniform float BV_16 = 0.5; 			uniform float BV_17 = 1.0; 			uniform float BV_18 = 5.0; 						uniform int				BV_13;			uniform sampler2D		BV_14;			uniform float4			BV_14_ST;			uniform float			BV_15;				struct appdata			{				float4 vertex:POSITION;					float3 BV_27:NORMAL;					float2 BV_28:TEXCOORD0;				};						struct v2f			{					float4 pos:SV_POSITION;					float2 BV_28:TEXCOORD0;					float4 BV_29:TEXCOORD1;				float3 v:TEXCOORD2;					float3 BV_31:TEXCOORD3;					float3 BV_32:TEXCOORD4;					float3 b:TEXCOORD5;					LIGHTING_COORDS(6,7)			};						struct BV_36 { 				float3 BV_37; 				float3 BV_38; 				float3 BV_39; 			}; 						void BV_33(float3 BV_31, out float3 BV_34, out float3 BV_35)			{				float s=BV_31.z<0?-1:1;				float3 BV_32=s*BV_31;				float e=BV_32.z;				float h=1/(1+e);				float3 v=float3(BV_32.y,-BV_32.x,0);				float hvx=h*v.x;				float hvxy=hvx*v.y;				BV_34=float3(e+hvx*v.x,hvxy,v.y);				BV_35=float3(hvxy,e+h*v.y*v.y,-v.x);				BV_34*=s;BV_35*=s;			}						v2f vert(appdata v) 			{				v2f output;					output.pos = mul(UNITY_MATRIX_MVP, v.vertex);				output.BV_28 = v.BV_28;				float4 BV_29 = mul(unity_ObjectToWorld, v.vertex);				output.BV_29 = BV_29;				output.v = _WorldSpaceCameraPos - BV_29.xyz;				output.BV_31 = mul(float4(v.BV_27, 0), unity_WorldToObject).xyz;				float3 Tu, Tv;				BV_33(output.BV_31, Tu, Tv);				output.BV_32 = Tu;					output.b = Tv;TRANSFER_VERTEX_TO_FRAGMENT(output);				return output;			}						float4 BV_40(sampler2D BV_41, float2 BV_28, float4x4 BV_42, float3 BV_43, bool BV_44)			{				float2 st = mul(BV_42, float4(BV_28, 0.0f, 1.0f)).xy;				float4 result = tex2D(BV_41, st) * float4(BV_43, 1.0f);				if (BV_44) 					result.rgb = 1.0f - result.rgb;				return result;			}						float3 BV_45(sampler2D BV_46, float2 BV_28, float4x4 BV_42, float BV_47, float3 BV_48, float3 BV_49, float3 BV_50)			{				float3x3 mtxTangent = {BV_48, BV_49, BV_50};					BV_48 = normalize(mul(mul((float3x3)BV_42, float3(1.0f, 0.0f, 0.0f)), mtxTangent)); 				BV_49 = normalize(mul(mul((float3x3)BV_42, float3(0.0f, 1.0f, 0.0f)), mtxTangent)); 				float3 avg = (1.0f / 3.0f).xxx;	float2 offset = max(fwidth(BV_28), float2(0.001f, 0.001f)); 					float2 st = mul(BV_42, float4(BV_28, 0.0f, 1.0f)).xy;				float h0 = dot(tex2D(BV_46, st).xyz, avg); 				float hx = dot(tex2D(BV_46, st + float2(offset.x, 0.0f)).xyz, avg); 				float hy = dot(tex2D(BV_46, st + float2(0.0f, offset.y)).xyz, avg); 				float2 BV_51 = float2(h0 - hx, h0 - hy) / offset;				return normalize(BV_50 + (BV_51.x * BV_48 + BV_51.y * BV_49) * BV_47);				}						float3 BV_52(sampler2D Map2, float2 BV_28, float4x4 BV_42, float BV_47, float3 BV_48, float3 BV_49, float3 BV_50)			{				float2 st = mul(BV_42, float4(BV_28, 0.0f, 1.0f)).xy;				float3 BV_56 =  2.0 * tex2D(Map2, st).xyz - 1.0;				return normalize(BV_47 * (BV_56.x * BV_48 + BV_56.y * BV_49) + BV_56.z * BV_50);			}						float3 BV_53( float3 BV_39, float3 BV_54 )			{ 				return normalize( BV_39 + BV_54 ); 			} 						float3 BV_83(int type, float2 BV_28, float3 BV_48, float3 BV_49, float3 BV_50, float3 Vw)			{					float4x4 bmt = {BV_14_ST.x,0,0,BV_14_ST.z,0,BV_14_ST.y,0,BV_14_ST.w,0,0,1,0,0,0,0,1};					if (type == 1)					BV_50 = BV_45(BV_14, BV_28, bmt, BV_15, BV_48, BV_49, BV_50);				else if (type == 2)					BV_50 = BV_52(BV_14, BV_28, bmt, BV_15, BV_48, BV_49, BV_50);								BV_50 = dot(-Vw, BV_50) < 0 ? BV_50 : -BV_50;				return BV_50;			}			float3 BV_84(float3 BV_85)			{				float3 BV_86;				if (0.0 == _WorldSpaceLightPos0.w) 				{					BV_86 = normalize(float3(_WorldSpaceLightPos0.xyz));				} 				else 				{					float3 vtx2Light = float3(_WorldSpaceLightPos0.xyz - BV_85);					BV_86 = normalize(vtx2Light);				}									return BV_86;			}						BV_36 BV_87( float BV_88, float3 color, float3 BV_89, float3 BV_90 )			{ 				const float PI = 3.141592654; 				BV_36 irrad; 				irrad.BV_37 = color * BV_88; // * PI; 
				irrad.BV_38 = BV_89 * BV_88; // * PI; 
				irrad.BV_39 = normalize( BV_90 ); 				return irrad; 			} 			float4 BV_95(float4 BV_92, float2 BV_28, float BV_93)			{				if(BV_93 == 0.0f)					return BV_92;				if(BV_93 == 1.0f)				{					///diffuse texture
					float4x4 dmt = {BV_4_ST.x,0,0,BV_4_ST.z,0,BV_4_ST.y,0,BV_4_ST.w,0,0,1,0,0,0,0,1};					float4 BV_94 = BV_40(BV_4, BV_28, dmt, float3(1,1,1), false);					return BV_94;				}				return BV_92;			}								float4 BV_55( float3 BV_56, float3 BV_39, float3 BV_54, float3 BV_57 )			{ 				float BV_58 = saturate(dot(BV_56, BV_39)); 				float BV_59 = saturate(dot(BV_56, BV_54)); 				float BV_60 = saturate(dot(BV_56, BV_57)); 				float BV_61 = saturate(dot(BV_54, BV_57)); 				return float4( BV_58, BV_59, BV_60, BV_61 ); 			} 						float3 BV_132(float3 BV_56, float3 BV_54, float BV_133,			   float3 BV_134, float3 BV_135, float BV_136, float3 BV_137)			{			   float BV_59 = saturate(dot(BV_56, BV_54));			   float3 BV_138     = (1.0f - BV_133) * BV_134;			   float3 BV_139 = lerp(BV_138, BV_135, BV_136);			   return lerp(BV_139, BV_138, pow(BV_59, BV_137));			}			float3 BV_140(float4 BV_141, float3 light, float BV_133,			   float3 BV_134, float BV_142, float3 BV_143)			{			   float3 color = lerp(BV_143, BV_134, pow(BV_141.x, BV_142) * BV_141.y);			   return light * color * pow(BV_141.x, BV_133 + 1.0f);			}			float3 BV_144(float4 BV_147, float3 light, float BV_145)			{			   return light * pow(BV_147.z, BV_145);			}			float3 BV_146(float4 BV_147, float3 light, float BV_145, bool BV_148)			{			   float s = pow(BV_147.z, BV_145);			   return light * (BV_148 ? smoothstep(0.5f, 0.8f, s) : s);			}			float BV_76(float4 BV_68, float BV_16, float BV_17, float BV_18 )			{ 				float f = lerp(BV_16, BV_17, pow(1.0f - BV_68.y, BV_18)); 				return f; 			} 						float4 frag(v2f input) : COLOR			{								float3 Vw = normalize(input.v);					float3 BV_48 = normalize(input.BV_32);				float3 BV_49 = normalize(input.b);				float3 BV_50 = normalize(input.BV_31);					   BV_50 = BV_83(BV_13, input.BV_28, BV_48,  BV_49, BV_50 , Vw);				float3 BV_86 = BV_84(input.BV_29);				BV_36 BV_110 = BV_87( LIGHT_ATTENUATION(input), _LightColor0.rgb, float3(1,1,1), BV_86 ); ; 					float3 BV_111 = BV_53( BV_86, Vw ); 				float4 BV_112 = BV_55( BV_50, BV_86, Vw, BV_111 ); 				float4 basecolor = BV_95(_DiffuseColor, input.BV_28, BV_7);				float3 BV_149 = BV_121.xyz;								float3 BV_150 = BV_132( BV_50, Vw, BV_120, basecolor, BV_149, BV_122, BV_123 ); 				float3 BV_151 = BV_140( BV_112, BV_110.BV_37, BV_120, basecolor, BV_127, BV_150 ); 				float3 BV_152 = BV_144( BV_112, BV_110.BV_37, BV_124 ); 				bool BV_153 = BV_129 == 0 ? false : true;				float3 BV_154 = BV_146( BV_112, BV_110.BV_38, BV_128, BV_153 );  				float3 BV_51      = BV_5   * BV_151;			   float3 BV_155 = BV_125 * BV_152 * (BV_126 >0 ? basecolor : 1.0f);			   float3 BV_89      = BV_10  * BV_154;						   float4 BV_156 = float4(BV_51 + BV_155 + BV_89, 1.0f);				return BV_156;						}ENDCG					} // Pass
 	} // SubShader
 	   	// Define a fallback shader. 
	FallBack "Diffuse"}